#!/bin/bash

# Couleurs pour les logs
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Demander le nom d'utilisateur Windows
read -p "Entrez votre nom d'utilisateur Windows : " windows_user
if [ -z "$windows_user" ]; then
    echo "‚ùå Aucun nom d'utilisateur fourni. Le script ne peut pas continuer."
    exit 1
fi

# Fonction pour les logs
log_info() {
    echo -e "${BLUE}‚ÑπÔ∏è $1${NC}"
}

log_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

# Fonction pour v√©rifier si Docker est en cours d'ex√©cution
check_docker() {
    if ! docker info >/dev/null 2>&1; then
        echo "‚ùå Erreur: Docker n'est pas en cours d'ex√©cution."
        echo "‚û°Ô∏è  Veuillez d√©marrer Docker et r√©essayer."
        exit 1
    fi
}

# Fonction pour v√©rifier si docker-compose est install√©
check_docker_compose() {
    if ! command -v docker-compose >/dev/null 2>&1; then
        echo "‚ùå Erreur: docker-compose n'est pas install√©."
        echo "‚û°Ô∏è  Veuillez installer docker-compose et r√©essayer."
        exit 1
    fi
}

# Fonction pour v√©rifier si une image existe
check_image() {
    local service="$1"
    local image="arosa-je-$service"
    
    log_info "V√©rification de l'image Docker pour le service '$service'..."
    if ! docker images --format "{{.Repository}}" | grep -q "^${image}$"; then
        log_warning "üîç Image '$image' non trouv√©e"
        log_info "üèóÔ∏è  Construction de l'image..."
        if docker-compose build "$service"; then
            log_success "‚ú® Image construite avec succ√®s"
        else
            echo "‚ùå Erreur lors de la construction de l'image"
            exit 1
        fi
    else
        log_success "üì¶ Image '$image' trouv√©e"
    fi
}

# Fonction pour v√©rifier la base de donn√©es
check_database() {
    log_info "V√©rification de la base de donn√©es..."
    
    if [ ! -f "./api/assets/database/arosaje.db" ]; then
        echo "‚ùå Base de donn√©es non trouv√©e!"
        echo "‚û°Ô∏è  Veuillez ex√©cuter 'bin/setup-api' avant de lancer les services"
        exit 1
    fi
    
    log_success "Base de donn√©es trouv√©e"
}

# Fonction pour v√©rifier si le dossier de la base de donn√©es existe
check_database_directory() {
    log_info "V√©rification des dossiers n√©cessaires..."
    
    local missing_dirs=()
    
    # V√©rification des dossiers requis
    if [ ! -d "./api/assets" ]; then
        missing_dirs+=("./api/assets")
    fi
    if [ ! -d "./api/assets/database" ]; then
        missing_dirs+=("./api/assets/database")
    fi
    if [ ! -d "./api/assets/img" ]; then
        missing_dirs+=("./api/assets/img")
    fi
    
    if [ ${#missing_dirs[@]} -ne 0 ]; then
        echo "‚ùå Structure de dossiers incompl√®te!"
        echo "üìÅ Dossiers manquants:"
        for dir in "${missing_dirs[@]}"; do
            echo "   - $dir"
        done
        echo "‚û°Ô∏è  Veuillez ex√©cuter 'bin/setup-api' avant de lancer les services"
        exit 1
    fi
    
    # V√©rification de la base de donn√©es
    check_database
    
    log_success "Configuration des dossiers valid√©e"
}

# Fonction pour arr√™ter l'√©mulateur Android
stop_android_emulator() {
    local adb_path_wsl="/mnt/c/Users/$windows_user/AppData/Local/Android/Sdk/platform-tools/adb.exe"
    local adb_path_windows=$(wslpath -w "$adb_path_wsl")
    
    if cmd.exe /c "$adb_path_windows" devices | grep -q "emulator-"; then
        log_info "Arr√™t de l'√©mulateur Android..."
        cmd.exe /c "$adb_path_windows" emu kill >/dev/null 2>&1 || true
        log_success "√âmulateur Android arr√™t√©"
    fi
}

# Fonction pour arr√™ter proprement les conteneurs
cleanup() {
    echo -e "\n\nüõë Arr√™t des conteneurs..."
    
    # Arr√™ter l'√©mulateur Android s'il est en cours d'ex√©cution
    stop_android_emulator
    
    # Arr√™ter les conteneurs sans les supprimer
    if [ "$1" = "all" ]; then
        docker-compose down
        echo "‚úÖ Tous les services ont √©t√© arr√™t√©s."
    else
        # Convertir les arguments en array pour g√©rer plusieurs services
        local services=($@)
        if [ ${#services[@]} -gt 0 ]; then
            # S'assurer que Redis est arr√™t√© si l'API est arr√™t√©e
            if [[ " ${services[@]} " =~ " api " ]]; then
                docker-compose stop api-redis api "${services[@]}"
            else
                docker-compose stop "${services[@]}"
            fi
            # V√©rifier si les ports sont toujours utilis√©s
            for service in "${services[@]}"; do
                case "$service" in
                    "api")
                        port=8000
                        ;;
                    "web")
                        port=3000
                        # Nettoyer les sockets Nitro
                        docker exec arosa-je-web rm -f /tmp/nitro/worker-*.sock 2>/dev/null || true
                        ;;
                    "mobile")
                        port=5000
                        ;;
                esac
                # Attendre que le port soit lib√©r√©
                timeout=5
                while lsof -i :$port >/dev/null 2>&1 && [ $timeout -gt 0 ]; do
                    sleep 1
                    ((timeout--))
                done
            done
            echo "‚úÖ Services arr√™t√©s : ${services[*]}"
        else
            docker-compose down
            echo "‚úÖ Tous les services ont √©t√© arr√™t√©s."
        fi
    fi
    
    # V√©rification finale des ports
    ports=(8000 3000 5000)
    for port in "${ports[@]}"; do
        if lsof -i :$port >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Le port $port est toujours utilis√©, for√ßage de la lib√©ration..."
            fuser -k $port/tcp >/dev/null 2>&1
        fi
    done

    # Nettoyage final des sockets Nitro si le service web √©tait en cours d'ex√©cution
    if docker ps -q -f name=arosa-je-web >/dev/null 2>&1; then
        echo "üßπ Nettoyage des sockets Nitro..."
        docker exec arosa-je-web rm -f /tmp/nitro/worker-*.sock 2>/dev/null || true
    fi
    
    echo "‚úÖ Tous les ports et sockets ont √©t√© lib√©r√©s"
    exit 0
}

# Fonction pour v√©rifier si un port est disponible
check_port() {
    local port=$1
    if lsof -i :$port >/dev/null 2>&1; then
        echo "‚ùå Le port $port est d√©j√† utilis√©"
        echo "‚û°Ô∏è  Arr√™t du processus utilisant le port $port..."
        fuser -k $port/tcp >/dev/null 2>&1
        sleep 2
    fi
}

# Fonction pour d√©marrer des services sp√©cifiques
start_services() {
    log_info "V√©rification de l'environnement..."
    check_docker
    check_docker_compose
    
    local services=("$@")
    local valid_services=1
    
    # V√©rifier que tous les services sont valides
    for service in "${services[@]}"; do
        case "$service" in
            "api"|"web"|"mobile")
                continue
                ;;
            *)
                echo "‚ùå Service invalide: $service"
                valid_services=0
                ;;
        esac
    done
    
    if [ $valid_services -eq 0 ]; then
        show_help
        exit 1
    fi
    
    # V√©rifier les ports avant de d√©marrer
    for service in "${services[@]}"; do
        case "$service" in
            "api")
                check_port 8000
                ;;
            "web")
                check_port 3000
                ;;
            "mobile")
                check_port 5000
                ;;
        esac
    done
    
    # Configuration sp√©cifique pour l'API si n√©cessaire
    if [[ " ${services[@]} " =~ " api " ]]; then
        check_database_directory
    fi
    
    # V√©rifier et construire les images
    for service in "${services[@]}"; do
        check_image "$service"
    done
    
    # Capture du signal SIGINT
    trap "cleanup ${services[*]}" SIGINT SIGTERM
    
    log_info "D√©marrage des services: ${services[*]}..."
    if ! docker-compose up -d "${services[@]}"; then
        echo "‚ùå Erreur lors du d√©marrage des services."
        echo "üìã Logs de l'erreur:"
        docker-compose logs "${services[@]}"
        exit 1
    fi

    # D√©marrer l'√©mulateur Android si le service mobile est inclus
    if [[ " ${services[@]} " =~ " mobile " ]]; then
        start_android_emulator
    fi

    log_success "Services d√©marr√©s avec succ√®s!"
    log_info "Affichage des logs..."
    echo "‚ÑπÔ∏è  Utilisez CTRL+C pour arr√™ter"
    
    # Utiliser --since pour n'afficher que les nouveaux logs
    docker-compose logs -f --since 0s "${services[@]}"
}

# Afficher l'aide
show_help() {
    echo "Usage: bin/up [services...]"
    echo ""
    echo "Options disponibles:"
    echo "  all               - D√©marre tous les services"
    echo "  api web mobile    - D√©marre les services sp√©cifi√©s (dans n'importe quel ordre)"
    echo ""
    echo "Exemples:"
    echo "  bin/up api web    - D√©marre l'API et le frontend web"
    echo "  bin/up api mobile - D√©marre l'API et l'application mobile"
    echo "  bin/up web       - D√©marre uniquement le frontend web"
    echo ""
    exit 1
}

# Fonction pour lancer l'√©mulateur Android
start_android_emulator() {
    log_info "D√©marrage de l'√©mulateur Android..."
    local avd_name="Pixel_6_API_35"
    
    # Chemins Windows
    local emulator_path_wsl="/mnt/c/Users/$windows_user/AppData/Local/Android/Sdk/emulator/emulator.exe"
    local adb_path_wsl="/mnt/c/Users/$windows_user/AppData/Local/Android/Sdk/platform-tools/adb.exe"
    
    # Convertir les chemins WSL en chemins Windows
    local emulator_path_windows=$(wslpath -w "$emulator_path_wsl")
    local adb_path_windows=$(wslpath -w "$adb_path_wsl")
    
    # V√©rifier si l'√©mulateur existe
    if [ ! -f "$emulator_path_wsl" ]; then
        log_warning "‚ùå √âmulateur non trouv√© √† l'emplacement : $emulator_path_wsl"
        log_warning "‚û°Ô∏è  Assurez-vous que le chemin est correct et que Android Studio est install√© sur Windows."
        return
    fi

    # Fonction pour ex√©cuter adb.exe de Windows
    adb_windows() {
        cmd.exe /c "$adb_path_windows" "$@" 2>/dev/null
    }

    # Tuer tout √©mulateur existant
    adb_windows kill-server
    sleep 2
    adb_windows start-server
    
    # Lancer l'√©mulateur avec des options optimis√©es
    log_info "Chemin de l'√©mulateur (Windows) : $emulator_path_windows"
    cmd.exe /c "$emulator_path_windows" -avd "$avd_name" \
        -gpu host \
        -no-snapshot-load \
        -no-audio \
        -no-boot-anim \
        -no-snapshot-save \
        -qemu -no-reboot &
    
    # Attendre que l'√©mulateur soit connect√©
    log_info "Attente de la connexion de l'√©mulateur..."
    timeout=90
    while [ $timeout -gt 0 ]; do
        # Afficher l'√©tat des appareils pour le debug
        echo "√âtat des appareils ADB:"
        adb_windows devices
        
        devices_output=$(adb_windows devices)
        if echo "$devices_output" | grep -q "emulator-.*device\|emulator-.*offline\|emulator-.*unauthorized"; then
            log_success "√âmulateur Android d√©tect√© (statut: $(echo "$devices_output" | grep "emulator-" | awk '{print $2}'))"
            break
        fi
        
        # Afficher le statut de l'√©mulateur pour le debug
        if [ $((timeout % 10)) -eq 0 ]; then
            log_info "Attente de l'√©mulateur... ($timeout secondes restantes)"
        fi
        
        sleep 1
        ((timeout--))
    done

    if [ $timeout -eq 0 ]; then
        devices_output=$(adb_windows devices)
        if echo "$devices_output" | grep -q "emulator-"; then
            log_warning "‚ö†Ô∏è  L'√©mulateur est pr√©sent mais pas encore pr√™t"
            log_info "√âtat actuel: $(echo "$devices_output" | grep "emulator-" | awk '{print $2}')"
            # On continue quand m√™me
        else
            log_warning "‚ö†Ô∏è  Aucun √©mulateur d√©tect√© apr√®s 90 secondes"
            return
        fi
    fi

    # Attendre que le syst√®me soit compl√®tement d√©marr√©
    log_info "Attente du d√©marrage complet du syst√®me..."
    timeout=180  # Augmentation du timeout √† 3 minutes
    while [ $timeout -gt 0 ]; do
        # Afficher l'√©tat du syst√®me pour le debug tous les 10 secondes
        if [ $((timeout % 10)) -eq 0 ]; then
            echo "√âtat du syst√®me:"
            adb_windows shell getprop sys.boot_completed
            adb_windows shell getprop init.svc.bootanim
            adb_windows shell getprop dev.bootcomplete
        fi
        
        # V√©rifier plusieurs propri√©t√©s syst√®me en g√©rant les retours chariot Windows
        boot_completed=$(adb_windows shell getprop sys.boot_completed | tr -d '\r')
        boot_animation=$(adb_windows shell getprop init.svc.bootanim | tr -d '\r')
        dev_complete=$(adb_windows shell getprop dev.bootcomplete | tr -d '\r')
        
        if [ "$boot_completed" = "1" ] && [ "$boot_animation" = "stopped" ]; then
            log_success "Syst√®me Android compl√®tement d√©marr√©"
            break
        fi
        sleep 2
        ((timeout-=2))
    done

    if [ $timeout -eq 0 ]; then
        # V√©rifier une derni√®re fois l'√©tat
        boot_completed=$(adb_windows shell getprop sys.boot_completed | tr -d '\r')
        if [ "$boot_completed" = "1" ]; then
            log_success "Syst√®me d√©marr√© (d√©tect√© lors de la derni√®re v√©rification)"
        else
            log_warning "‚ö†Ô∏è  Timeout atteint, mais on continue quand m√™me..."
        fi
    fi

    # Attendre un peu plus pour s'assurer que le syst√®me est vraiment pr√™t
    log_info "Attente suppl√©mentaire pour s'assurer que le syst√®me est stable..."
    sleep 15

    # Installer et lancer l'application
    log_info "Installation de l'application..."
    
    # Se d√©placer dans le dossier mobile
    if ! cd mobile; then
        log_warning "‚ùå Dossier mobile non trouv√©"
        return 1
    fi
    
    # R√©cup√©rer l'ID de l'√©mulateur
    emulator_id=$(adb_windows devices | grep "emulator-" | cut -f1)
    if [ -z "$emulator_id" ]; then
        log_warning "‚ùå √âmulateur non trouv√©"
        cd ..
        return 1
    fi
    
    # Construire et installer l'application avec Flutter
    log_info "Construction et installation de l'application avec Flutter..."
    if flutter build apk --debug; then
        log_success "APK construit avec succ√®s"
        
        # Chemin de l'APK (conversion en chemin Windows)
        local apk_path_wsl="$(pwd)/build/app/outputs/flutter-apk/app-debug.apk"
        local apk_path_windows=$(wslpath -w "$apk_path_wsl")
        
        log_info "Chemin de l'APK: $apk_path_windows"
        
        # Installer l'APK avec ADB
        log_info "Installation de l'APK..."
        install_output=$(adb_windows install -r "$apk_path_windows" 2>&1)
        install_status=$?
        
        echo "R√©sultat de l'installation:"
        echo "$install_output"
        
        if [ $install_status -eq 0 ] && echo "$install_output" | grep -q "Success"; then
            log_success "Application install√©e avec succ√®s"
            
            # Lancer l'application
            log_info "Lancement de l'application..."
            if adb_windows shell am start -n "com.example.mobile/.MainActivity"; then
                log_success "Application lanc√©e avec succ√®s"
            else
                log_warning "‚ö†Ô∏è  Impossible de lancer l'application"
                log_info "V√©rification du package..."
                adb_windows shell pm list packages | grep -i "com.example.mobile"
            fi
        else
            log_warning "‚ùå Erreur lors de l'installation de l'APK"
            log_info "D√©tails de l'erreur:"
            echo "$install_output"
            cd ..
            return 1
        fi
    else
        log_warning "‚ùå Erreur lors de la construction de l'application"
        cd ..
        return 1
    fi
    
    # Retourner au dossier pr√©c√©dent
    cd ..
}

# Fonction pour v√©rifier les fichiers d'environnement
check_env_files() {
    log_info "V√©rification des fichiers d'environnement..."
    
    if [ ! -d "./env" ] || [ ! -f "./env/.env.api" ] || [ ! -f "./env/.env.web" ] || [ ! -f "./env/.env.mobile" ]; then
        echo "‚ùå Fichiers d'environnement manquants!"
        echo "‚û°Ô∏è  Veuillez ex√©cuter 'bin/setup-env' avant de lancer les services"
        exit 1
    fi
    
    # V√©rifier que les fichiers ne sont pas vides
    if [ ! -s "./env/.env.api" ] || [ ! -s "./env/.env.web" ] || [ ! -s "./env/.env.mobile" ]; then
        echo "‚ùå Certains fichiers d'environnement sont vides!"
        echo "‚û°Ô∏è  Veuillez ex√©cuter 'bin/setup-env' pour configurer les variables d'environnement"
        exit 1
    fi
    
    log_success "Fichiers d'environnement valid√©s"
}

case "$1" in
    "all")
        log_info "V√©rification de l'environnement..."
        check_docker
        check_docker_compose
        check_env_files
        check_database_directory
        check_image "api"
        check_image "web"
        check_image "mobile"
        
        # Capture du signal SIGINT pour tous les services
        trap "cleanup all" SIGINT SIGTERM
        
        log_info "D√©marrage de tous les services..."
        if ! docker-compose up -d; then
            echo "‚ùå Erreur lors du d√©marrage des conteneurs."
            echo "üìã Logs de l'erreur:"
            docker-compose logs
            exit 1
        fi

        log_success "Tous les services d√©marr√©s avec succ√®s!"
        log_info "Affichage des logs..."
        echo "‚ÑπÔ∏è  Utilisez CTRL+C pour arr√™ter"
        
        # Utiliser --since pour n'afficher que les nouveaux logs
        docker-compose logs -f --since 0s
        ;;
    "")
        show_help
        ;;
    *)
        log_info "V√©rification de l'environnement..."
        check_docker
        check_docker_compose
        check_env_files
        start_services "$@"
        ;;
esac 