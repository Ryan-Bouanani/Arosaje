#!/bin/bash

# V√©rifier le format des fins de ligne du script lui-m√™me
if file "$0" | grep -q "CRLF"; then
    echo "‚ö†Ô∏è  Le script contient des fins de ligne Windows (CRLF)"
    echo "‚û°Ô∏è  Conversion automatique en format Unix (LF)..."
    if command -v dos2unix >/dev/null 2>&1; then
        dos2unix "$0"
        echo "‚úÖ Conversion effectu√©e. Veuillez relancer le script."
        exit 0
    else
        echo "‚ùå dos2unix n'est pas install√©."
        echo "‚û°Ô∏è  Veuillez installer dos2unix avec : sudo apt-get install dos2unix"
        exit 1
    fi
fi

# V√©rifier le format des fins de ligne du script lui-m√™me
if file "$0" | grep -q "CRLF"; then
    echo "‚ö†Ô∏è  Le script contient des fins de ligne Windows (CRLF)"
    echo "‚û°Ô∏è  Conversion automatique en format Unix (LF)..."
    if command -v dos2unix >/dev/null 2>&1; then
        dos2unix "$0"
        echo "‚úÖ Conversion effectu√©e. Veuillez relancer le script."
        exit 0
    else
        echo "‚ùå dos2unix n'est pas install√©."
        echo "‚û°Ô∏è  Veuillez installer dos2unix avec : sudo apt-get install dos2unix"
        exit 1
    fi
fi

# Couleurs pour les logs
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Variables globales pour l'√©mulateur
windows_user=""
avd_name=""
verbose_mode=false

# Fonction pour les logs
log_info() {
    echo -e "${BLUE}‚ÑπÔ∏è $1${NC}"
}

log_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"
}

# Fonction pour v√©rifier si Docker est en cours d'ex√©cution
check_docker() {
    if ! docker info >/dev/null 2>&1; then
        echo "‚ùå Erreur: Docker n'est pas en cours d'ex√©cution."
        echo "‚û°Ô∏è  Veuillez d√©marrer Docker et r√©essayer."
        exit 1
    fi
}

# Fonction pour v√©rifier si docker-compose est install√©
check_docker_compose() {
    if ! command -v docker-compose >/dev/null 2>&1; then
        echo "‚ùå Erreur: docker-compose n'est pas install√©."
        echo "‚û°Ô∏è  Veuillez installer docker-compose et r√©essayer."
        exit 1
    fi
}

# Fonction pour v√©rifier si une image existe
check_image() {
    local service="$1"
    local image="arosa-je-$service"
    
    log_info "V√©rification de l'image Docker pour le service '$service'..."
    if ! docker images --format "{{.Repository}}" | grep -q "^${image}$"; then
        log_warning "üîç Image '$image' non trouv√©e"
        log_info "üèóÔ∏è  Construction de l'image..."
        if docker-compose build "$service"; then
            log_success "‚ú® Image construite avec succ√®s"
        else
            echo "‚ùå Erreur lors de la construction de l'image"
            exit 1
        fi
    else
        log_success "üì¶ Image '$image' trouv√©e"
    fi
}

# Fonction pour v√©rifier si le dossier de la base de donn√©es existe
check_assets_directory() {
    log_info "V√©rification des dossiers n√©cessaires..."
    
    local missing_dirs=()
    
    # V√©rification des dossiers requis
    if [ ! -d "./api/assets" ]; then
        missing_dirs+=("./api/assets")
    fi
    if [ ! -d "./api/assets/img" ]; then
        missing_dirs+=("./api/assets/img")
    fi
    
    if [ ${#missing_dirs[@]} -ne 0 ]; then
        echo "‚ùå Structure de dossiers incompl√®te!"
        echo "üìÅ Dossiers manquants:"
        for dir in "${missing_dirs[@]}"; do
            echo "   - $dir"
        done
        echo "‚û°Ô∏è  Veuillez ex√©cuter 'bin/setup-api' avant de lancer les services"
        exit 1
    fi
    
    log_success "Configuration des dossiers valid√©e"
}

# Fonction pour arr√™ter l'√©mulateur Android
stop_android_emulator() {
    local adb_path_wsl="/mnt/c/Users/$windows_user/AppData/Local/Android/Sdk/platform-tools/adb.exe"
    local adb_path_windows=$(wslpath -w "$adb_path_wsl")
    
    if cmd.exe /c "$adb_path_windows" devices | grep -q "emulator-"; then
        log_info "Arr√™t de l'√©mulateur Android..."
        cmd.exe /c "$adb_path_windows" emu kill >/dev/null 2>&1 || true
        log_success "√âmulateur Android arr√™t√©"
    fi
}

# Fonction pour arr√™ter proprement les conteneurs
cleanup() {
    echo -e "\n\nüõë Arr√™t des conteneurs..."
    
    # Arr√™ter l'√©mulateur Android s'il est en cours d'ex√©cution
    stop_android_emulator
    
    # Arr√™ter les conteneurs sans les supprimer
    if [ "$1" = "all" ]; then
        docker-compose down
        echo "‚úÖ Tous les services ont √©t√© arr√™t√©s."
    else
        # Convertir les arguments en array pour g√©rer plusieurs services
        local services=($@)
        if [ ${#services[@]} -gt 0 ]; then
            # S'assurer que Redis est arr√™t√© si l'API est arr√™t√©e
            if [[ " ${services[@]} " =~ " api " ]]; then
                docker-compose stop api-redis api "${services[@]}"
            else
                docker-compose stop "${services[@]}"
            fi
            # V√©rifier si les ports sont toujours utilis√©s
            for service in "${services[@]}"; do
                case "$service" in
                    "api")
                        port=8000
                        ;;
                    "web")
                        port=3000
                        # Nettoyer les sockets Nitro
                        docker exec arosa-je-web rm -f /tmp/nitro/worker-*.sock 2>/dev/null || true
                        ;;
                    "mobile")
                        port=5000
                        ;;
                esac
                # Attendre que le port soit lib√©r√©
                timeout=5
                while lsof -i :$port >/dev/null 2>&1 && [ $timeout -gt 0 ]; do
                    sleep 1
                    ((timeout--))
                done
            done
            echo "‚úÖ Services arr√™t√©s : ${services[*]}"
        else
            docker-compose down
            echo "‚úÖ Tous les services ont √©t√© arr√™t√©s."
        fi
    fi
    
    # V√©rification finale des ports
    ports=(8000 3000 5000)
    for port in "${ports[@]}"; do
        if lsof -i :$port >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Le port $port est toujours utilis√©, for√ßage de la lib√©ration..."
            fuser -k $port/tcp >/dev/null 2>&1
        fi
    done

    # Nettoyage final des sockets Nitro si le service web √©tait en cours d'ex√©cution
    if docker ps -q -f name=arosa-je-web >/dev/null 2>&1; then
        echo "üßπ Nettoyage des sockets Nitro..."
        docker exec arosa-je-web rm -f /tmp/nitro/worker-*.sock 2>/dev/null || true
    fi
    
    echo "‚úÖ Tous les ports et sockets ont √©t√© lib√©r√©s"
    exit 0
}

# Fonction pour v√©rifier si un port est disponible
check_port() {
    local port=$1
    if lsof -i :$port >/dev/null 2>&1; then
        echo "‚ùå Le port $port est d√©j√† utilis√©"
        echo "‚û°Ô∏è  Arr√™t du processus utilisant le port $port..."
        fuser -k $port/tcp >/dev/null 2>&1
        sleep 2
    fi
}

# Fonction pour d√©marrer des services sp√©cifiques
start_services() {
    log_info "V√©rification de l'environnement..."
    check_docker
    check_docker_compose
    
    local services=("$@")
    local valid_services=1
    
    # V√©rifier que tous les services sont valides
    for service in "${services[@]}"; do
        case "$service" in
            "api"|"web"|"mobile")
                continue
                ;;
            *)
                echo "‚ùå Service invalide: $service"
                valid_services=0
                ;;
        esac
    done
    
    if [ $valid_services -eq 0 ]; then
        show_help
        exit 1
    fi

    # Si le service mobile est demand√©, r√©cup√©rer automatiquement le nom d'utilisateur Windows
    if [[ " ${services[@]} " =~ " mobile " ]]; then
        windows_user=$(get_windows_username)
        if [ -z "$windows_user" ]; then
            log_warning "‚ùå Impossible de r√©cup√©rer automatiquement le nom d'utilisateur Windows"
            read -p "Veuillez entrer votre nom d'utilisateur Windows manuellement : " windows_user
            if [ -z "$windows_user" ]; then
                echo "‚ùå Aucun nom d'utilisateur fourni. Le script ne peut pas continuer."
                exit 1
            fi
        else
            log_success "Nom d'utilisateur Windows d√©tect√© : $windows_user"
        fi

        # Lister les AVD disponibles
        echo -e "\nüì± Liste des √©mulateurs Android disponibles :"
        emulator_path="/mnt/c/Users/$windows_user/AppData/Local/Android/Sdk/emulator/emulator.exe"
        emulator_path_windows=$(wslpath -w "$emulator_path")
        
        # Changer vers le r√©pertoire Windows temporairement pour √©viter le warning
        (cd /mnt/c && cmd.exe /c "$emulator_path_windows" -list-avds)

        # Demander le nom de l'AVD
        echo -e "\n‚û°Ô∏è  Choisissez un √©mulateur dans la liste ci-dessus"
        read -p "Entrez le nom de l'√©mulateur Android (AVD) : " avd_name
        if [ -z "$avd_name" ]; then
            echo "‚ùå Aucun nom d'√©mulateur fourni. Le script ne peut pas continuer."
            exit 1
        fi
    fi
    
    # V√©rifier les ports avant de d√©marrer
    for service in "${services[@]}"; do
        case "$service" in
            "api")
                check_port 8000
                ;;
            "web")
                check_port 3000
                ;;
            "mobile")
                check_port 5000
                ;;
        esac
    done
    
    # Configuration sp√©cifique pour l'API si n√©cessaire
    if [[ " ${services[@]} " =~ " api " ]]; then
        check_assets_directory
    fi
    
    # V√©rifier et construire les images
    for service in "${services[@]}"; do
        check_image "$service"
    done
    
    # Capture du signal SIGINT
    trap "cleanup ${services[*]}" SIGINT SIGTERM
    
    log_info "D√©marrage des services: ${services[*]}..."
    if ! docker-compose up -d "${services[@]}"; then
        echo "‚ùå Erreur lors du d√©marrage des services."
        echo "üìã Logs de l'erreur:"
        docker-compose logs "${services[@]}"
        exit 1
    fi

    # D√©marrer l'√©mulateur Android si le service mobile est inclus
    if [[ " ${services[@]} " =~ " mobile " ]]; then
        start_android_emulator
    fi

    log_success "Services d√©marr√©s avec succ√®s!"
    log_info "Affichage des logs..."
    echo "‚ÑπÔ∏è  Utilisez CTRL+C pour arr√™ter"
    
    # Utiliser --since pour n'afficher que les nouveaux logs
    docker-compose logs -f --since 0s "${services[@]}"
}

# Afficher l'aide
show_help() {
    echo "Usage: bin/up [options] [services...]"
    echo ""
    echo "Options disponibles:"
    echo "  -v                - Mode verbeux (affiche tous les logs)"
    echo "  all               - D√©marre tous les services"
    echo "  api web mobile    - D√©marre les services sp√©cifi√©s (dans n'importe quel ordre)"
    echo ""
    echo "Exemples:"
    echo "  bin/up api web    - D√©marre l'API et le frontend web"
    echo "  bin/up -v mobile  - D√©marre l'application mobile en mode verbeux"
    echo "  bin/up web       - D√©marre uniquement le frontend web"
    echo ""
    exit 1
}

# Fonction pour lancer l'√©mulateur Android
start_android_emulator() {
    log_info "D√©marrage de l'√©mulateur Android..."
    
    # Chemins Windows
    local emulator_path_wsl="/mnt/c/Users/$windows_user/AppData/Local/Android/Sdk/emulator/emulator.exe"
    local adb_path_wsl="/mnt/c/Users/$windows_user/AppData/Local/Android/Sdk/platform-tools/adb.exe"
    
    # Convertir les chemins WSL en chemins Windows
    local emulator_path_windows=$(wslpath -w "$emulator_path_wsl")
    local adb_path_windows=$(wslpath -w "$adb_path_wsl")
    
    # V√©rifier si l'√©mulateur existe
    if [ ! -f "$emulator_path_wsl" ]; then
        log_warning "‚ùå √âmulateur non trouv√© √† l'emplacement : $emulator_path_wsl"
        return
    fi

    # Fonction pour ex√©cuter adb.exe de Windows
    adb_windows() {
        if [ "$verbose_mode" = true ]; then
            cmd.exe /c "$adb_path_windows" "$@"
        else
            cmd.exe /c "$adb_path_windows" "$@" 2>/dev/null
        fi
    }

    # Red√©marrer le serveur ADB
    adb_windows kill-server >/dev/null 2>&1
    adb_windows start-server >/dev/null 2>&1
    
    # Lancer l'√©mulateur avec des options optimis√©es
    if [ "$verbose_mode" = true ]; then
        cmd.exe /c "$emulator_path_windows" -avd "$avd_name" \
            -gpu host \
            -no-snapshot-load \
            -no-audio \
            -no-boot-anim \
            -no-snapshot-save \
            -qemu -no-reboot &
    else
        cmd.exe /c "$emulator_path_windows" -avd "$avd_name" \
            -gpu host \
            -no-snapshot-load \
            -no-audio \
            -no-boot-anim \
            -no-snapshot-save \
            -qemu -no-reboot >/dev/null 2>&1 &
    fi
    
    # Attendre que l'√©mulateur soit connect√©
    log_info "Attente du d√©marrage de l'√©mulateur..."
    timeout=90
    while [ $timeout -gt 0 ]; do
        if adb_windows devices | grep -q "emulator-.*device"; then
            break
        fi
        sleep 1
        ((timeout--))
    done

    if [ $timeout -eq 0 ]; then
        log_warning "‚ùå L'√©mulateur n'a pas d√©marr√© correctement"
        return 1
    fi

    # Attendre que le syst√®me soit compl√®tement d√©marr√©
    timeout=60
    while [ $timeout -gt 0 ]; do
        boot_completed=$(adb_windows shell getprop sys.boot_completed | tr -d '\r')
        if [ "$boot_completed" = "1" ]; then
            break
        fi
        sleep 2
        ((timeout-=2))
    done

    if [ $timeout -eq 0 ]; then
        log_warning "‚ùå Le syst√®me Android n'a pas d√©marr√© compl√®tement"
    fi

    # Installation de l'application
    cd mobile || exit 1
    
    # Nettoyer le build pr√©c√©dent
    if [ "$verbose_mode" = true ]; then
        flutter clean
    else
        flutter clean >/dev/null 2>&1
    fi
    
    # Rendre gradlew ex√©cutable
    chmod +x android/gradlew >/dev/null 2>&1
    
    # Construction de l'application
    log_info "Construction de l'application..."
    if [ "$verbose_mode" = true ]; then
        if ! flutter build apk --debug; then
            log_warning "‚ùå Erreur lors de la construction de l'application"
            cd ..
            return 1
        fi
    else
        if ! flutter build apk --debug >/dev/null 2>&1; then
            log_warning "‚ùå Erreur lors de la construction de l'application"
            flutter build apk --debug --verbose  # Afficher les logs d√©taill√©s en cas d'erreur
            cd ..
            return 1
        fi
    fi

    # Installation de l'APK
    local apk_path_wsl="$(pwd)/build/app/outputs/flutter-apk/app-debug.apk"
    local apk_path_windows=$(wslpath -w "$apk_path_wsl")
    
    log_info "Installation de l'application..."
    if ! adb_windows install -r "$apk_path_windows" >/dev/null 2>&1; then
        log_warning "‚ùå Erreur lors de l'installation de l'APK"
        adb_windows install -r "$apk_path_windows"  # Afficher les logs d√©taill√©s en cas d'erreur
        cd ..
        return 1
    fi

    # Lancement de l'application
    if ! adb_windows shell am start -n "com.example.mobile/.MainActivity" >/dev/null 2>&1; then
        log_warning "‚ùå Erreur lors du lancement de l'application"
        cd ..
        return 1
    fi

    log_success "Application install√©e et lanc√©e avec succ√®s"
    cd ..
}

# Fonction pour v√©rifier les fichiers d'environnement
check_env_files() {
    log_info "V√©rification des fichiers d'environnement..."
    
    if [ ! -d "./env" ] || [ ! -f "./env/.env.api" ] || [ ! -f "./env/.env.web" ] || [ ! -f "./env/.env.mobile" ]; then
        echo "‚ùå Fichiers d'environnement manquants!"
        echo "‚û°Ô∏è  Veuillez ex√©cuter 'bin/setup-env' avant de lancer les services"
        exit 1
    fi
    
    # V√©rifier que les fichiers ne sont pas vides
    if [ ! -s "./env/.env.api" ] || [ ! -s "./env/.env.web" ] || [ ! -s "./env/.env.mobile" ]; then
        echo "‚ùå Certains fichiers d'environnement sont vides!"
        echo "‚û°Ô∏è  Veuillez ex√©cuter 'bin/setup-env' pour configurer les variables d'environnement"
        exit 1
    fi
    
    log_success "Fichiers d'environnement valid√©s"
}

# Fonction pour r√©cup√©rer automatiquement le nom d'utilisateur Windows
get_windows_username() {
    # Essayer de r√©cup√©rer le nom d'utilisateur Windows via /mnt/c/Windows/System32/cmd.exe
    local win_username
    win_username=$(powershell.exe '$env:USERNAME' 2>/dev/null | tr -d '\r')
    
    if [ -n "$win_username" ]; then
        echo "$win_username"
        return 0
    fi
    
    # Fallback : essayer de r√©cup√©rer depuis le chemin du r√©pertoire utilisateur Windows
    win_username=$(cmd.exe /c "echo %USERNAME%" 2>/dev/null | tr -d '\r')
    if [ -n "$win_username" ]; then
        echo "$win_username"
        return 0
    fi
    
    return 1
}

case "$1" in
    "-v")
        verbose_mode=true
        shift
        if [ -z "$1" ]; then
            show_help
        elif [ "$1" = "all" ]; then
            log_info "Mode verbeux activ√©"
            log_info "V√©rification de l'environnement..."
            check_docker
            check_docker_compose
            check_env_files
            check_assets_directory
            check_image "api"
            check_image "web"
            check_image "mobile"
            
            # Capture du signal SIGINT pour tous les services
            trap "cleanup all" SIGINT SIGTERM
            
            log_info "D√©marrage de tous les services..."
            if ! docker-compose up -d; then
                echo "‚ùå Erreur lors du d√©marrage des conteneurs."
                echo "üìã Logs de l'erreur:"
                docker-compose logs
                exit 1
            fi

            log_success "Tous les services d√©marr√©s avec succ√®s!"
            log_info "Affichage des logs..."
            echo "‚ÑπÔ∏è  Utilisez CTRL+C pour arr√™ter"
            
            docker-compose logs -f --since 0s
        else
            log_info "Mode verbeux activ√©"
            start_services "$@"
        fi
        ;;
    "all")
        log_info "V√©rification de l'environnement..."
        check_docker
        check_docker_compose
        check_env_files
        check_assets_directory
        check_image "api"
        check_image "web"
        check_image "mobile"
        
        # Capture du signal SIGINT pour tous les services
        trap "cleanup all" SIGINT SIGTERM
        
        log_info "D√©marrage de tous les services..."
        if ! docker-compose up -d; then
            echo "‚ùå Erreur lors du d√©marrage des conteneurs."
            echo "üìã Logs de l'erreur:"
            docker-compose logs
            exit 1
        fi

        log_success "Tous les services d√©marr√©s avec succ√®s!"
        log_info "Affichage des logs..."
        echo "‚ÑπÔ∏è  Utilisez CTRL+C pour arr√™ter"
        
        docker-compose logs -f --since 0s
        ;;
    "")
        show_help
        ;;
    *)
        log_info "V√©rification de l'environnement..."
        check_docker
        check_docker_compose
        check_env_files
        start_services "$@"
        ;;
esac 